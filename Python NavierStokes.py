from numpy import *from matplotlib.pyplot import *from matplotlib import animationdef poisson_rec(um, vm, p1, x, y, dt, dx, dy, F, G, n_iteraciones, cond_frontera, f):    p = p1.copy()    pn = zeros_like(p1)    f[1:-1, 1:-1] = rho*((F[1:-1,2:]-F[1:-1,0:-2])/(2.*dx)+(G[2:,1:-1]-G[0:-2,1:-1])/(2.*dy)+\                        ((um[1:-1,2:]-um[1:-1,0:-2])/dx+(vm[2:,1:-1]-vm[0:-2,1:-1])/dy)/(2.*dt)-\                        ((um[1:-1,2:]-um[1:-1,0:-2])/(2.*dx))**2-((vm[2:,1:-1]-vm[0:-2,1:-1])/(2.*dy))**2-\                        2*((um[2:,1:-1]-um[0:-2,1:-1])/(2.*dy))*((vm[1:-1,2:]-vm[1:-1,0:-2])/(2.*dx)))                            f[1:-1,0] = rho*((F[1:-1,1]-F[1:-1,-2])/(2.*dx)+(G[2:,0]-G[0:-2,0])/(2.*dy)+\                        ((um[1:-1,1]-um[1:-1,-2])/dx+(vm[2:,0]-vm[0:-2,0])/dy)/(2.*dt)-\                        ((um[1:-1,1]-um[1:-1,-2])/(2.*dx))**2-((vm[2:,0]-vm[0:-2,0])/(2.*dy))**2-\                        2*((um[2:,0]-um[0:-2,0])/(2.*dy))*((vm[1:-1,1]-vm[1:-1,-2])/(2.*dx)))                            f[1:-1,-1] = rho*((F[1:-1,1]-F[1:-1,-2])/(2.*dx)+(G[2:,-1]-G[0:-2,-1])/(2.*dy)+\                        ((um[1:-1,1]-um[1:-1,-2])/dx+(vm[2:,-1]-vm[0:-2,-1])/dy)/(2.*dt)-\                        ((um[1:-1,1]-um[1:-1,-2])/(2.*dx))**2-((vm[2:,-1]-vm[0:-2,-1])/(2.*dy))**2-\                        2*((um[2:,-1]-um[0:-2,-1])/(2.*dy))*((vm[1:-1,1]-vm[1:-1,-2])/(2.*dx)))                                                   for i in range(n_iteraciones):        pn = p.copy()        #Se aplica la condicion de estabilidad en el interior del dominio        p[1:-1,1:-1] = ( dy**2*(pn[1:-1,2:]+pn[1:-1,0:-2,]) + dx**2*(pn[2:,1:-1]+pn[0:-2,1:-1]) -\                        dx**2 *dy**2 *f[1:-1,1:-1] )/(2*(dx**2+dy**2))                                p[1:-1,0] = ( dy**2*(pn[1:-1,1]+pn[1:-1,-2]) + dx**2*(pn[2:,0]+pn[0:-2,0]) -\                            dx**2 *dy**2 *f[1:-1,0])/(2*(dx**2+dy**2))                    p[1:-1,-1] = ( dy**2*(pn[1:-1,1]+pn[1:-1,-2]) + dx**2*(pn[2:,-1]+pn[0:-2,-1]) -\                            dx**2 *dy**2 *f[1:-1,-1])/(2*(dx**2+dy**2))          #Se aplican las condiciones de frontera        pn = cond_frontera(um, vm, p, x, y, dx, dy, dt, F, G, f)    return pndef discret_vel(un, vn, pn, dx, dy, dt, x, y, cond_frontVEL, rho, nu, F, G, ciclo):    U = un.copy()    U_ = un.copy()    V = vn.copy()    V_ = vn.copy()        if ciclo%30<>0:        U_[1:-1,1:-1] = un[1:-1,1:-1] - dt/dx * (un[1:-1,2:]**2-un[1:-1,1:-1]**2) \                        - dt/dy * (un[2:,1:-1]*vn[2:,1:-1]-un[1:-1,1:-1]*vn[1:-1,1:-1])\                        - dt/dx * (pn[1:-1,2:]-pn[1:-1,1:-1])/rho + dt * F[1:-1,1:-1]\                        + nu*dt/dx**2 * (un[1:-1,2:]-2*un[1:-1,1:-1]+un[1:-1,0:-2])\                        + nu*dt/dy**2 * (un[2:,1:-1]-2*un[1:-1,1:-1]+un[0:-2,1:-1])                                V_[1:-1,1:-1] = vn[1:-1,1:-1] - dt/dx * (un[1:-1,2:]*vn[1:-1,2:]-un[1:-1,1:-1]*vn[1:-1,1:-1]) \                        - dt/dy * (vn[2:,1:-1]**2-vn[1:-1,1:-1]**2)\                        - dt/dy * (pn[2:,1:-1]-pn[1:-1,1:-1])/rho + dt * G[1:-1,1:-1]\                        + nu*dt/dx**2 * (vn[1:-1,2:]-2*vn[1:-1,1:-1]+vn[1:-1,0:-2])\                        + nu*dt/dy**2 * (vn[2:,1:-1]-2*vn[1:-1,1:-1]+vn[0:-2,1:-1])                                U_[1:-1,0] = un[1:-1,0] - dt/dx * (un[1:-1,1]**2-un[1:-1,0]**2) \                        - dt/dy * (un[2:,0]*vn[2:,0]-un[1:-1,0]*vn[1:-1,0])\                        - dt/dx * (pn[1:-1,1]-pn[1:-1,0])/rho + dt * F[1:-1,0]\                        + nu*dt/dx**2 * (un[1:-1,1]-2*un[1:-1,0]+un[1:-1,-2])\                        + nu*dt/dy**2 * (un[2:,0]-2*un[1:-1,0]+un[0:-2,0])        V_[1:-1,0] = vn[1:-1,0] - dt/dx * (un[1:-1,1]*vn[1:-1,1]-un[1:-1,0]*vn[1:-1,0]) \                        - dt/dy * (vn[2:,0]**2-vn[1:-1,0]**2)\                        - dt/dy * (pn[2:,0]-pn[1:-1,0])/rho + dt * G[1:-1,0]\                        + nu*dt/dx**2 * (vn[1:-1,1]-2*vn[1:-1,0]+vn[1:-1,-2])\                        + nu*dt/dy**2 * (vn[2:,0]-2*vn[1:-1,0]+vn[0:-2,0])        U_[1:-1,-1] = un[1:-1,-1] - dt/dx * (un[1:-1,1]**2-un[1:-1,0-1]**2) \                        - dt/dy * (un[2:,-1]*vn[2:,-1]-un[1:-1,-1]*vn[1:-1,-1])\                        - dt/dx * (pn[1:-1,1]-pn[1:-1,-1])/rho + dt * F[1:-1,-1]\                        + nu*dt/dx**2 * (un[1:-1,1]-2*un[1:-1,-1]+un[1:-1,-2])\                        + nu*dt/dy**2 * (un[2:,-1]-2*un[1:-1,-1]+un[0:-2,-1])        V_[1:-1,-1] = vn[1:-1,-1] - dt/dx * (un[1:-1,1]*vn[1:-1,1]-un[1:-1,-1]*vn[1:-1,-1]) \                        - dt/dy * (vn[2:,0]**2-vn[1:-1,0]**2)\                        - dt/dy * (pn[2:,0]-pn[1:-1,0])/rho + dt * G[1:-1,0]\                        + nu*dt/dx**2 * (vn[1:-1,1]-2*vn[1:-1,0]+vn[1:-1,-2])\                        + nu*dt/dy**2 * (vn[2:,0]-2*vn[1:-1,0]+vn[0:-2,0])        else:        U_[1:-1,1:-1] = 0.25*(un[1:-1,2:]+un[1:-1,0:-2]+un[2:,1:-1]+un[0:-2,1:-1]) \                        - dt/dx * (un[1:-1,2:]**2-un[1:-1,1:-1]**2) \                        - dt/dy * (un[2:,1:-1]*vn[2:,1:-1]-un[1:-1,1:-1]*vn[1:-1,1:-1])\                        - dt/dx * (pn[1:-1,2:]-pn[1:-1,1:-1])/rho + dt * F[1:-1,1:-1]\                        + nu*dt/dx**2 * (un[1:-1,2:]-2*un[1:-1,1:-1]+un[1:-1,0:-2])\                        + nu*dt/dy**2 * (un[2:,1:-1]-2*un[1:-1,1:-1]+un[0:-2,1:-1])                                V_[1:-1,1:-1] = 0.25*(vn[1:-1,2:]+vn[1:-1,0:-2]+vn[2:,1:-1]+vn[0:-2,1:-1]) \                        - dt/dx * (un[1:-1,2:]*vn[1:-1,2:]-un[1:-1,1:-1]*vn[1:-1,1:-1]) \                        - dt/dy * (vn[2:,1:-1]**2-vn[1:-1,1:-1]**2)\                        - dt/dy * (pn[2:,1:-1]-pn[1:-1,1:-1])/rho + dt * G[1:-1,1:-1]\                        + nu*dt/dx**2 * (vn[1:-1,2:]-2*vn[1:-1,1:-1]+vn[1:-1,0:-2])\                        + nu*dt/dy**2 * (vn[2:,1:-1]-2*vn[1:-1,1:-1]+vn[0:-2,1:-1])                                U_[1:-1,0] = 0.25*(un[1:-1,1]+un[1:-1,-2]+un[2:,0]+un[0:-2,0])\                        - dt/dx * (un[1:-1,1]**2-un[1:-1,0]**2) \                        - dt/dy * (un[2:,0]*vn[2:,0]-un[1:-1,0]*vn[1:-1,0])\                        - dt/dx * (pn[1:-1,1]-pn[1:-1,0])/rho + dt * F[1:-1,0]\                        + nu*dt/dx**2 * (un[1:-1,1]-2*un[1:-1,0]+un[1:-1,-2])\                        + nu*dt/dy**2 * (un[2:,0]-2*un[1:-1,0]+un[0:-2,0])        V_[1:-1,0] = 0.25*(vn[1:-1,1]+vn[1:-1,-2]+vn[2:,0]+vn[0:-2,0])\                        - dt/dx * (un[1:-1,1]*vn[1:-1,1]-un[1:-1,0]*vn[1:-1,0]) \                        - dt/dy * (vn[2:,0]**2-vn[1:-1,0]**2)\                        - dt/dy * (pn[2:,0]-pn[1:-1,0])/rho + dt * G[1:-1,0]\                        + nu*dt/dx**2 * (vn[1:-1,1]-2*vn[1:-1,0]+vn[1:-1,-2])\                        + nu*dt/dy**2 * (vn[2:,0]-2*vn[1:-1,0]+vn[0:-2,0])        U_[1:-1,-1] = 0.25*(vn[1:-1,1]+vn[1:-1,-2]+vn[2:,-1]+vn[0:-2,-1])\                        - dt/dx * (un[1:-1,1]**2-un[1:-1,0-1]**2) \                        - dt/dy * (un[2:,-1]*vn[2:,-1]-un[1:-1,-1]*vn[1:-1,-1])\                        - dt/dx * (pn[1:-1,1]-pn[1:-1,-1])/rho + dt * F[1:-1,-1]\                        + nu*dt/dx**2 * (un[1:-1,1]-2*un[1:-1,-1]+un[1:-1,-2])\                        + nu*dt/dy**2 * (un[2:,-1]-2*un[1:-1,-1]+un[0:-2,-1])        V_[1:-1,-1] = 0.25*(vn[1:-1,1]+vn[1:-1,-2]+vn[2:,-1]+vn[0:-2,-1])\                        - dt/dx * (un[1:-1,1]*vn[1:-1,1]-un[1:-1,-1]*vn[1:-1,-1]) \                        - dt/dy * (vn[2:,0]**2-vn[1:-1,0]**2)\                        - dt/dy * (pn[2:,0]-pn[1:-1,0])/rho + dt * G[1:-1,0]\                        + nu*dt/dx**2 * (vn[1:-1,1]-2*vn[1:-1,0]+vn[1:-1,-2])\                        + nu*dt/dy**2 * (vn[2:,0]-2*vn[1:-1,0]+vn[0:-2,0])                     U[1:-1,1:-1] = 0.5*( un[1:-1,1:-1] + U_[1:-1,1:-1]\                            - dt/dx * (U_[1:-1,1:-1]**2 - U_[1:-1,0:-2]**2)\                            - dt/dy * (U_[1:-1,1:-1]*V_[1:-1,1:-1] - U_[0:-2,1:-1]*V_[0:-2,1:-1])\                            - dt/dx * (pn[1:-1,1:-1]-pn[1:-1,0:-2])/rho + dt * F[1:-1,1:-1]\                            + nu*dt/dx**2 * (U_[1:-1,2:]-2*U_[1:-1,1:-1]+U_[1:-1,0:-2])\                            + nu*dt/dy**2 * (U_[2:,1:-1]-2*U_[1:-1,1:-1]+U_[0:-2,1:-1])                        )    V[1:-1,1:-1] = 0.5*( vn[1:-1,1:-1] + V_[1:-1,1:-1]\                            - dt/dx * (U_[1:-1,1:-1]*V_[1:-1,1:-1] - U_[1:-1,0:-2]*V_[1:-1,0:-2])\                            - dt/dy * (V_[1:-1,1:-1]**2 - V_[0:-2,1:-1]**2)\                            - dt/dx * (pn[1:-1,1:-1]-pn[0:-2,1:-1])/rho + dt * G[1:-1,1:-1]\                            + nu*dt/dx**2 * (V_[1:-1,2:]-2*V_[1:-1,1:-1]+V_[1:-1,0:-2])\                            + nu*dt/dy**2 * (V_[2:,1:-1]-2*V_[1:-1,1:-1]+V_[0:-2,1:-1])                        )                            U[1:-1,0] = 0.5*( un[1:-1,0] + U_[1:-1,0]\                            - dt/dx * (U_[1:-1,0]**2 - U_[1:-1,-2]**2)\                            - dt/dy * (U_[1:-1,0]*V_[1:-1,0] - U_[0:-2,0]*V_[0:-2,0])\                            - dt/dx * (pn[1:-1,0]-pn[1:-1,-2])/rho + dt * F[1:-1,0]\                            + nu*dt/dx**2 * (U_[1:-1,1]-2*U_[1:-1,0]+U_[1:-1,-2])\                            + nu*dt/dy**2 * (U_[2:,0]-2*U_[1:-1,0]+U_[0:-2,0])                    )    V[1:-1,0] = 0.5*( vn[1:-1,0] + V_[1:-1,0]\                            - dt/dx * (U_[1:-1,0]*V_[1:-1,0] - U_[1:-1,-2]*V_[1:-1,-2])\                            - dt/dy * (V_[1:-1,0]**2 - V_[0:-2,0]**2)\                            - dt/dx * (pn[1:-1,0]-pn[0:-2,0])/rho + dt * G[1:-1,0]\                            + nu*dt/dx**2 * (V_[1:-1,1]-2*V_[1:-1,0]+V_[1:-1,-2])\                            + nu*dt/dy**2 * (V_[2:,0]-2*V_[1:-1,0]+V_[0:-2,0])                        )    U[1:-1,-1] = 0.5*( un[1:-1,-1] + U_[1:-1,-1]\                            - dt/dx * (U_[1:-1,-1]**2 - U_[1:-1,-2]**2)\                            - dt/dy * (U_[1:-1,-1]*V_[1:-1,-1] - U_[0:-2,-1]*V_[0:-2,-1])\                            - dt/dx * (pn[1:-1,-1]-pn[1:-1,-2])/rho + dt * F[1:-1,-1]\                            + nu*dt/dx**2 * (U_[1:-1,1]-2*U_[1:-1,-1]+U_[1:-1,-2])\                            + nu*dt/dy**2 * (U_[2:,-1]-2*U_[1:-1,-1]+U_[0:-2,-1])                    )    V[1:-1,-1] = 0.5*( vn[1:-1,-1] + V_[1:-1,-1]\                            - dt/dx * (U_[1:-1,-1]*V_[1:-1,-1] - U_[1:-1,-2]*V_[1:-1,-2])\                            - dt/dy * (V_[1:-1,-1]**2 - V_[0:-2,-1]**2)\                            - dt/dx * (pn[1:-1,-1]-pn[0:-2,-1])/rho + dt * G[1:-1,-1]\                            + nu*dt/dx**2 * (V_[1:-1,1]-2*V_[1:-1,-1]+V_[1:-1,-2])\                            + nu*dt/dy**2 * (V_[2:,-1]-2*V_[1:-1,-1]+V_[0:-2,-1])                        )                            Un, Vn = cond_frontVEL(U, V, pn, dx, dy, dt, x, y, F, G)    return Un, Vndef vorticidad(un, vn, dx, dy):    Xi = zeros_like(un)    Xi[2:-2,2:-2] = (un[0:-4,2:-2]-8*un[1:-3,2:-2]+8*un[3:-1,2:-2]-un[4:,2:-2])/(12*dy)\                    -(vn[2:-2,0:-4]-8*vn[2:-2,1:-3]+8*vn[2:-2,3:-1]-vn[2:-2,4:])/(12*dx)    return Xi    def avance_en_tiempo(u0, v0, p0, cond_frontVEL, cond_frontP, nt, nx, ny, dx, dy, x, y, nu, rho, sigma, n_iteraciones, F, G, flag=False):        t = 0        un = zeros((ny, nx))    vn = zeros((ny, nx))    Pn = zeros((ny, nx))    f = zeros((ny, nx))    Xin = zeros((ny, nx))        if flag:         Uhist=[]        Vhist=[]        Phist=[]        Xhist=[]        thist=[]        u = u0    v = v0    P = p0        for n in range(nt):                #Se copia el valor de la funcion u en el arreglo un        un = u.copy()        vn = v.copy()        Pn = P.copy()        Xin = vorticidad(un, vn, dx, dy)                if flag:             Uhist.append(un)            Vhist.append(vn)            Phist.append(Pn)            Xhist.append(Xin)            thist.append(t)        dt = sigma / (max(amax(un)/dx, amax(vn)/dy) + max(2*nu/dx**2, 2*nu/dy**2))        t = t+dt        #Para cada punto en el espacio se calcula el valor         #de la funcion en el tiempo siguiente        P = poisson_rec(un, vn, Pn, x, y, dt, dx, dy, F, G, n_iteraciones, cond_frontP, f)                u, v = discret_vel(un, vn, Pn, dx, dy, dt, x, y, cond_frontVEL, rho, nu, F, G, n)                Xin = vorticidad(u, v, dx, dy)            if flag:        return Uhist, Vhist, Phist, Xhist, thist    else:        return u, v, P, Xin, tdef cond_frontvel(um, vm, pm, dt, dx, dy, x, y, F, G):    um[0,:] = 20.0*tanh(50.0*(-0.5*ly))    # en y=0    um[-1,:] = 20.0*tanh(50.0*(0.5*ly))   # en y=1        vm[0,:] = 0.0    # en y=0    vm[-1,:] = 0.0   # en y=1    return um, vmdef cond_front_p(um, vm, pm, x, y, dx, dy, dt, F, G, f):    pm[0,:] = 1.0     # en y=0    pm[-1,:] = 1.0   # en y=1    return pm lx = 3.ly = 1.nx = 101ny = 101nt = 200dx = lx/(nx-1)dy = ly/(ny-1)sigma = 0.3n_iteraciones = 1000nu = 0.001rho = 1.0dt = sigma*dx*dy/nuN = 10x = linspace(0., lx, nx)y = linspace(0., ly, ny)X, Y = meshgrid(x, y)#Se define un arreglo de puros cerosu0 = zeros((ny, nx))v0 = zeros((ny, nx))p0 = zeros((ny, nx))u0 = 20.0*tanh(50.0*(Y-0.5*ly))v0[9*ny/20:11*ny/20,:] = 5.0*sin(10.0*pi*X[9*ny/20:11*ny/20,:]/lx)F = -100.0*cos(pi/3.0)*ones((ny, nx))G = -100.0*sin(pi/3.0)*ones((ny, nx))#Se imponen las condiciones de fronterau0, v0 = cond_frontvel(u0, v0, p0, dt, dx, dy, x, y, F, G)p0 = cond_front_p(u0, v0, p0, x, y, dx, dy, dt, F, G, zeros((ny,nx)))Uh, Vh, Ph, Xih, th =  avance_en_tiempo(u0, v0, p0, cond_frontvel, cond_front_p,                               nt, nx, ny, dx, dy, x, y, nu, rho, sigma, n_iteraciones, F, G, True)UMag = [sqrt(Uh[i]**2+Vh[i]**2) for i in range(0,nt)]salto = 1figanim = figure(figsize=(10,10));Ax = figanim.add_subplot(211);Bx = figanim.add_subplot(212);Ax.set_xlim(0,1);Ax.set_ylim(0,1);Bx.set_xlim(0,1);Bx.set_ylim(0,1);cbar_ax = figanim.add_axes([0.85, 0.57, 0.02, 0.3]);cbar_bx = figanim.add_axes([0.85, 0.13, 0.02, 0.3]);subplots_adjust(wspace = 0.5);def init():    Ax.cla()    Bx.cla()    campo_vectorial = Ax.quiver([],[],[],[])    return campo_vectorial,# Esta funcion se llama de manera secuencial para cada elemento i.def animate(i,ax,bx,fig):    NN = i*salto    ax.cla()    bx.cla()    cbar_ax.cla()    cbar_bx.cla()    ax.set_title(u'Campo de velocidades y vorticidad')    bx.set_title(u'Campo de velocidades y presion')    figanim.subplots_adjust(right=0.8)    contornof = ax.contour(X, Y, Xih[NN], 25)    figanim.colorbar(contornof, cbar_ax)    contornof2 = bx.contourf(X, Y, Ph[NN], 25)    figanim.colorbar(contornof2, cbar_bx)    #campo_vectorial = ax.quiver(X[::N,::N], Y[::N,::N], Uh[NN][::N,::N], Vh[NN][::N,::N])    return contornof, contornof2,anim = animation.FuncAnimation(figanim, animate, init_func=init, frames=nt/salto, fargs=(Ax, Bx, figanim), interval=5);anim.save("Animacion.mp4", fps=10);